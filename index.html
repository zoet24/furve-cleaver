<!DOCTYPE html>
<html>
  <head>
    <title>Furve Cleaver</title>
    <link href="https://fonts.googleapis.com/css?family=Antic+Slab" rel="stylesheet">
  </head>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.6.0/p5.js"></script>

  <body>

    <div class="container">
      <div id="curveArena">
      </div>
      <div>
        <button onclick="start(3)">Start</button>
      </div>
    </div>

    <style>
      .container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
      }
    </style>
  </body>

  <script>
    // Set up canvas
    var game = {
      canvas_dimension: 400,

      // If game is active
      started: false,
    }

    function setup() {
      canvas = createCanvas(game.canvas_dimension, game.canvas_dimension);
      colorMode(HSB);
      background('black');
      canvas.parent('curveArena');
    }

    // Set up player variables
    var players = [];

    var player = {
      // Speed of player
      speed: [1, 1, 1],

      // How quickly player can turn
      angle: [2, 2, 2],

      // Keyboard controls
      keys: ['LEFT_ARROW','RIGHT_ARROW','A','D','J','L'],
      keys_code: [[37,39],[65,68],[74,76]],

      // Player aesthetic
      player_colour: ["red", "blue", "green"],
      player_width: [5, 5, 5],      
    }

    function genAngle(min, max) {
      return ((Math.random() * (max - min) ) + min);
    }

    // Pass in number of players from UI and generate random position and angles for each player
    function start(num_players) {
      if (game.started == false) {
        players = [];
          for (var i = 0;i < num_players;i++) {
            x = Math.floor(Math.random() * 0.8*game.canvas_dimension) + 1;
            y = Math.floor(Math.random() * 0.8*game.canvas_dimension) + 1;

            if ((x >= 0) && (x < (0.5*game.canvas_dimension)) && (y >= 0) && (y < (0.5*game.canvas_dimension))) {
              min = 1.75
              max = 2.25
            } else if ((x >= 0.5*game.canvas_dimension) && (x <= (game.canvas_dimension)) && (y >= 0) && (y < (0.5*game.canvas_dimension))) {
              min = 0.25
              max = 0.75
            } else if ((x >= 0) && (x < (0.5*game.canvas_dimension)) && (y >= (0.5*game.canvas_dimension)) && (y < (game.canvas_dimension))) {
              min = 1.25
              max = 1.75
            } else {
              min = 0.75
              max = 1.25
            }

            angleMultiplier = genAngle(min, max)
            angle = Math.PI * angleMultiplier

            line_tmp = new Line(x,y);
            line_tmp.add_position(x+player.speed[i],y+player.speed[i]);
            line_tmp.move(angle);
            players.push(line_tmp);
          }
          game.started = true;
        }
      }

    // Change path of player if keypad is pressed; if not continue in a straight line
    function draw() {
      if (game.started) {
        for (var i=0;i<players.length;i++) {
          if (keyIsDown(player.keys_code[i][0])) {
            players[i].move(-player.angle[i]* Math.PI / 180);
          }
          else if (keyIsDown(player.keys_code[i][1])) {
            players[i].move(player.angle[i]* Math.PI / 180);
          }
          else {
            players[i].move(0);
          }
        }
        var lose = Line.is_ended(players);
        if (lose != -1) {
          game.started = false;
        }
        Line.display_lines(players);
      }
    }

    // Construct line with position and angle
    class Line{
      constructor(a,b){
        this.array=[];
        this.array.push([a,b]);
      }

      add_position(a,b){
        this.array.push([a,b]);
      }

    // The player moves depending on the calculated angle
      move(angle) {
        var a = this.array[this.array.length-2];
        var b = this.array[this.array.length-1];
        var vectorx = (b[0]-a[0])
        var vectory = (b[1]-a[1])

        // Take the vector of the previous move and apply a rotation matrix
        var x = vectorx*Math.cos(angle)-vectory*Math.sin(angle)
        var y = vectorx*Math.sin(angle)+vectory*Math.cos(angle)

        // Add this new vector to the last coordinate
        var new_x = b[0]+x
        var new_y = b[1]+y
        
        this.array.push([new_x,new_y]);
      }

      // Display the last line
      display() {
        for(var i=this.array.length-2;i<this.array.length-1;i++) {
          line(this.array[i][0],this.array[i][1],this.array[i+1][0],this.array[i+1][1]);
        }
      }

      // Display line for each player
      static display_lines(player_lines){
        for (var i = 0;i < player_lines.length;i++) {
          stroke(player.player_colour[i]);
          strokeWeight(player.player_width[i]);
          player_lines[i].display();
        }
      }

      // Check if the game is ended
      static is_ended(player_lines) {
        // Check if player has hit wall
        for (var i = 0;i < player_lines.length;i++) {
          for (var k = 0;k < 2;k++) {
            var x = player_lines[i].array[player_lines[i].array.length-1][k];
            if (x <= 0 || x >= game.canvas_dimension) {
              print("Hit wall");
              return true;
            }
          }
        }
        // Check if player has hit itself/another player
        for (var i = 0;i < player_lines.length;i++) {
          for (var j = 0;j < player_lines.length;j++) {
            for (var k = 0;k < player_lines[j].array.length;k++) {
              var x = player_lines[i].array[player_lines[i].array.length-1]
              var y = player_lines[j].array[k]
              if (Math.abs(x[0]-y[0])<player.player_width[i]*0.8 && (Math.abs(x[1]-y[1])<player.player_width[i]*0.8)) {
                // Check if player has hit itself
                if (i == j && k < player_lines[j].array.length-player.player_width[i]-1) {
                  print('Hit self');
                  return i;
                }
                // Check if player has hit other player
                else if (i != j) {
                  print("Hit other");
                  return i;
                }
              }
            }
          }
        }
        return -1;
      }
    }
    
  </script>
</html>